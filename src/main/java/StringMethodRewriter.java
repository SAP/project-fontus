import org.objectweb.asm.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.Collection;
import java.util.regex.Matcher;


import static org.objectweb.asm.Opcodes.*;

public class StringMethodRewriter extends ClassVisitor {
    private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

    private final Collection<BlackListEntry> blacklist = new ArrayList<>();
    private static final String mainDescriptor = "([Ljava/lang/String;)V";
    private static final String newMainDescriptor = "("+ Constants.TStringArrayDesc +")V";

    private String owner;

    StringMethodRewriter(ClassVisitor cv) {
        super(ASM7, cv);

        this.blacklist.add(new BlackListEntry("main", mainDescriptor, ACC_PUBLIC | ACC_STATIC));
    }

    @Override
    public void visit(
            final int version,
            final int access,
            final String name,
            final String signature,
            final String superName,
            final String[] interfaces) {
        this.owner = name;
        super.visit(version, access, name, signature, superName, interfaces);
    }

    @Override
    public FieldVisitor visitField(int access, String name, String descriptor,
                                   String signature, Object value) {

        Matcher descMatcher = Constants.strPattern.matcher(descriptor);
        if(descMatcher.find()) {
            logger.info("Replacing field {}:{} ({})", access, name, descriptor);
            String newDescriptor = descMatcher.replaceAll(Constants.TStringDesc);
            return super.visitField(access, name, newDescriptor, signature, value);
        } else {
            return super.visitField(access, name, descriptor, signature, value);
        }
    }

    // Autogenerated by asmify
    private void createMainWrapperMethod(MethodVisitor mv) {
        mv.visitCode();
        Label label0 = new Label();
        mv.visitLabel(label0);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitInsn(ARRAYLENGTH);
        mv.visitTypeInsn(ANEWARRAY, Constants.TString);
        mv.visitVarInsn(ASTORE, 1);
        Label label1 = new Label();
        mv.visitLabel(label1);
        mv.visitInsn(ICONST_0);
        mv.visitVarInsn(ISTORE, 2);
        Label label2 = new Label();
        mv.visitLabel(label2);
        mv.visitFrame(Opcodes.F_APPEND,2, new Object[] {Constants.TStringArrayDesc, Opcodes.INTEGER}, 0, null);
        mv.visitVarInsn(ILOAD, 2);
        mv.visitVarInsn(ALOAD, 1);
        mv.visitInsn(ARRAYLENGTH);
        Label label3 = new Label();
        mv.visitJumpInsn(IF_ICMPGE, label3);
        Label label4 = new Label();
        mv.visitLabel(label4);
        mv.visitVarInsn(ALOAD, 1);
        mv.visitVarInsn(ILOAD, 2);
        mv.visitTypeInsn(NEW, Constants.TString);
        mv.visitInsn(DUP);
        mv.visitVarInsn(ALOAD, 0);
        mv.visitVarInsn(ILOAD, 2);
        mv.visitInsn(AALOAD);
        mv.visitMethodInsn(INVOKESPECIAL, Constants.TString, "<init>", "(Ljava/lang/String;)V", false);
        mv.visitInsn(AASTORE);
        Label label5 = new Label();
        mv.visitLabel(label5);
        mv.visitIincInsn(2, 1);
        mv.visitJumpInsn(GOTO, label2);
        mv.visitLabel(label3);
        mv.visitFrame(Opcodes.F_CHOP,1, null, 0, null);
        mv.visitVarInsn(ALOAD, 1);
        mv.visitMethodInsn(INVOKESTATIC, this.owner, "$main", newMainDescriptor, false);
        Label label6 = new Label();
        mv.visitLabel(label6);
        mv.visitInsn(RETURN);
        mv.visitMaxs(6, 3);
        mv.visitEnd();
    }

    @Override
    public MethodVisitor visitMethod(
            final int access,
            final String name,
            final String descriptor,
            final String signature,
            final String[] exceptions) {

        Matcher descMatcher = Constants.strPattern.matcher(descriptor);
        MethodVisitor mv;
        // Create a new main method, wrapping the regular one and translating all Strings to IASStrings
        if(access == (ACC_PUBLIC | ACC_STATIC) && name.equals("main") && descriptor.equals(mainDescriptor)) {
            logger.info("Creating proxy main method");
            MethodVisitor v = super.visitMethod(ACC_PUBLIC | ACC_STATIC, "main", mainDescriptor, null, null);
            this.createMainWrapperMethod(v);
            logger.info("Processing renamed main method.");
            mv = super.visitMethod(access, "$main", newMainDescriptor, signature, exceptions);
        } else if (!this.blacklist.contains(new BlackListEntry(name, descriptor, access)) && descMatcher.find()) {
            logger.info("Rewriting method signature {} ({})", name, descriptor);
            String newDescriptor = descMatcher.replaceAll(Constants.TStringDesc);
            mv = super.visitMethod(access, name, newDescriptor, signature, exceptions);
        } else {
            mv = super.visitMethod(access, name, descriptor, signature, exceptions);
        }
        return new StringRewriterVisitor(mv);
    }
}
